package com.master.chapter009;

/**
 * @ClassName: SortTest
 * @Package: com.master.chapter009
 * @Description: 排序算法基本介绍
 * @Datetime: 2021/6/7 21:54
 * @author: ColorXJH
 */
public class SortTest {
    public static void main(String[] args) {

    }
}

//排序算法的基本介绍
    //1:排序是将一组数据，依指定的顺序进行排列的过程
    //2:排序的分类：内部排序：将需要处理的所有数据都加载到内部存储器中进行排序
            //   外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序
    //3：常见的排序算法分类：排序：1：内部排序（使用内存），2：外部排序（使用内存与外存）
        //1.1插入排序 1.2选择排序 1.3交换排序 1.4归并排序 1.5基数排序（桶排序）
            //1.1.1直接插入排序  1.1.2希尔排序  1.2.1简单选择排序 1.2.2堆排序 1.3.1冒泡排序 1.3.2快速排序


//算法的时间复杂度
    //度量一个程序（算法）执行时间的；两种方法
        //1:事后统计的方法
            //这种方法可行，但是有两个问题，一是要想对设计的算法的运行性能进行评测，需要实际运行该程序，，二是所得时间的统计量
            //依赖于计算机的硬件，软件等环境因素，这种方式要在同一台计算机的相同状态下运行，才能比较哪个算法速度更快
        //2:事前估算的算法：
            //通过分析某个算法的时间复杂度来判断哪个算法更优

//时间频度：一个算法花费的时间与算法中语句的执行次数成正比，哪个算法中的语句执行次数多，它花费的时间就多，一个算法中语句执行的次数称为
    //语句频度或时间频度，计为T(n)
        //举例说明：计算1-100所有数字之和，我们设计两种算法：
            //1: for(int i=1;i<=100;i++){total+=i;} ==>T(n)=n+1:计算100次，最后结尾判断1次
            //2:total=(1+100)*100/2==>T(n)=1
    //在一个时间频度时，
        //可以忽略常数项
        //忽略低次项
        //忽略系数

//时间复杂度
    //1:一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时
        //T(n)/f(n)的极限值为不等于0的常熟，则称f(n)是T(n)的同数量级函数，记作T(n)=O(f(n)),称O(f(n))为算法的渐进时间复杂度，简称：时间复杂度
    //2:T(n)不同，但时间复杂度可能相同，如T(n)=n^2+7n+6与T(n)=3n^2++2n+2,他们的T（n）不同，但时间复杂度相同，都为o(n^2)
    //3:计算时间复杂度的方法：
        //1:用常数1代替运行时间中的所有加法常数
        //2:修改后的运行次数函数中，只保留最高阶项
        //3：去除最高阶项的系数

//常见的时间复杂度
    //1:常数阶：O(1)
        //无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是O(1)
    //2:对数阶：O(log2 N)
        //int i=1; while(i<n){i=i*2;}
        //在while循环里，每次都将i乘以2，乘完之后，i距离n就越来越近了，假设循环x次之后，i就大于n了，退出循环，也就是说2的x次方等于n
        //x=log2 N ,也就是说循环log2 N次以后，这个代码就结束了，因此这个代码的时间复杂度为O(log2 N),这里的2是根据代码变化的
        //驾驶循环中i=i*3,则是O(log3 N)
    //3:线性阶：O(n)
        //单层的for循环 for(int 1=1;i<n;i++){j=i++} T(n)=n+1=>T(n)=O(n)
    //4:线性对数阶：O(nlog2 N)
        //将时间复杂度为O(logN)的代码循环n遍的话，那么它的时间复杂度就是n*O(logN)==>O(nlogN)
        //for(int m=1;m<n;m++){i=1;while(i<n){i=i*2}}
    //5:平方阶：O(N^2)
        //双层的for循环 O(n*n),根据内外不同的循环次数可以为O(n*m)
    //6:立方阶：O(n^3)
        //三层的for循环
    //7:k次方阶：O(n^k)
        //k层for循环
    //8:指数阶：O(2^N)
    //常见的算法时间复杂度由小到大以此为：O(1)<O(log2 N)<O(n)<O(nlog2 N)<O(n^2)<0(n^3)<O(n^k)<O(2^n)<O(n!),随着问题规模n
    //的不断增大，上述时间复杂度不断增大，算法的执行效率越低
        //注意：要尽量避免使用指数阶的算法


//平均时间复杂度和最坏时间复杂度
    //1:平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间
    //2:最坏情况下的时间复杂度称为最坏时间复杂度，一般讨论的时间复杂度均是最坏情况下的时间复杂度
        //这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，，这就保证了算法的运行时间不会比最坏情况更长
    //3:平均时间复杂度和最坏时间复杂度是否一致，和算法有关
        //排序法               平均时间            最差情形            稳定度         额外空间            备注
        //冒泡                O(n^2)              O(n^2)             稳定           O(1)            n小时较好
        //交换                O(n^2)              O(n^2)             不稳定          O(1)            n小时较好
        //选择                O(n^2)              O(n^2)             不稳定          O(1)            n小时较好
        //插入                O(n^2)              O(n^2)              稳定           O(1)           大部分已排序时较好
        //基数                O(logn M)           O(logn M)           稳定           O(n)           M是真数(0-9)n是基数（个十百千）
        //shell              O(nlogN)            O(n^s 1<s<2)        不稳定         O(1)            s是所选分组
        //快速                O(nlogN)            O(n^2)              不稳定         O(nlogN)        n较大时较好
        //归并                O(nlogN)            O(nlogN)            稳定           O(1)            n较大时较好
        //堆                 O(nlogN)            O(nlogN)            不稳定          O(1)            n较大时较好


//算法的空间复杂度简介：
    //1:类似于时间复杂度的讨论，一个算法的空间复杂度定义为该算法所耗费的存贮空间，它也是问题规模n的函数
    //2:空间复杂度是对一个算法在运行过程中临时占用存储空间大小的度量，当n较大时，将占用较多的存储单元，例如快速排序和归并排序
    //3:在做算法分析时，主要讨论的是时间复杂度，从用户使用体验上来看，更看重的是程序执行的速度，一些缓存产品（redis,memcache）和算法（基数排序）本质就是用空间换时间
