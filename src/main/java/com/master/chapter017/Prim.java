package com.master.chapter017;

/**
 * @ClassName: Prim  普利姆算法
 * @Package: com.master.chapter017
 * @Description:
 * @Datetime: 2021/10/11 23:17
 * @author: ColorXJH
 */
public class Prim {
}

//应用场景--修路问题
    //有一个六边形的七个村庄（边角和中心各一个），现在需要修路把7个村庄都联通，各个村庄的距离分别不同，问如何修路能保证各个村庄都能联通
    //并且总的修路里程最少？

//思路：1：将10条边全部都链接起来，但是总的里程肯定是最长的
//正确思路：尽可能的选择少的路线，并且每条路线最小，保证总里程数最少

//最小生成树
    //修路问题的本质就是最小生成树问题，先介绍一下最小生成树（Minimum Cost Spanning Tree），简称MST
        //1:给定一个带权的无向连接图，如何选择一颗生成树，使树上所有边上权的总和最小，这叫最小生成树
        //2:N个顶点，一定有N-1条边
        //3：包含全部顶点
        //4:N-1条边都在图中
        //5:举例说明如图：
        //6:求最小生成树的算法主要是普利姆算法和克鲁斯卡尔算法
                //1---2                        2
                //|   |===>  1--2--3--4    1   3
                //3===4                        4
//普利姆算法
    //1:普利姆算法求最小生成树，也就是在包含N个顶点的连通图中，找出只有n-1条边包含所有n个顶点的联通子图，也就是所谓的极小联通子图
        //2:算法如下：
            //1设G=(V,E)是联通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合
            //2若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入到集合U中，标记顶点v的visited[u]=1
            //3若集合U中顶点ui与集合V-U中的顶点vj之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边（ui,vj）加入集合D中，
                //标记visited[vj]=1
            //4重复步骤2，知道U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边
            //5提示：单独看步骤很难理解：，通过代码比较好理解-169