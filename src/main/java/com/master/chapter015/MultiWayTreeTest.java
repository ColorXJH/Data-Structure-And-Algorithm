package com.master.chapter015;

/**
 * @author ColorXJH
 * @version 1.0
 * @description: 多叉树
 * @date 2021/7/20 10:35
 */
public class MultiWayTreeTest {
    public static void main(String[] args) {
        //多叉树的实现自己百度，一般不要求
    }
}

//二叉树与B树
    //二叉树的原理分析
    //二叉树的操作操作效率较高，但是也存在问题
        //1：二叉树是需要加载到内存的，如果二叉树的节点较少，则没什么问题，但是如果二叉树的节点很多
            //比如一亿，就存在如下问题：
        //2：在构建二叉树时，需要多次进行i/o操作（海量数据存储在数据库或者文件中），节点海量，构建二叉树时
            //速度有影响
        //3：节点海量，也会造成二叉树的高度很大，会降低操作速度

//多叉树
    //1：在二叉树中，每个节点有数据项，最多有两个子节点，如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树
    //2：2-3树，2-3-4树就是多叉树，多叉树通过重新组织节点，减少树的高度，能多二叉树进行优化
    //3：下面列举一些2-3树
        //                16
        //          8 12       27         8 12  三节点     27  二节点
        //       7  10  14   17  29      7 10 14        17  29

//B树的基本介绍
    //B树通过重新组织节点，降低了树的高度，并且减少了i/o读写次数来提升效率
    //文件系统以及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页的大小通常为4K）
        //这样每个节点只需要一次i/o就可以完全载入
    //将树的度M设置为1024,在600亿个元素中最多只需要4次i/o操作就可以读取到想要的元素，B树（B+）广泛
        //应用于文件存储系统和数据库系统
//节点的度：一个节点有几个子节点就有几个度
//树的度：所有节点中节点的度最大的值

//2-3树 基本介绍
    //2-3树是最简单的B树结构，具有如下特征
    //1；2-3树的所有叶子节点都在同一层（只要是B树，都满足这个条件）
    //2：有两个子节点的节点叫做二节点，二节点要么没有子节点，要么有两个子节点
    //3：有三个子节点的节点叫做三节点，三节点要么没有子节点，要么有三个子节点
    //4：2-3树是由二节点和三节点构成的树


//2-3树应用案例
    //将数列【16，24，12，32，14，26，34，10，8，28，38，20】，构建成2-3树，并保证数据插入的大小顺序
    //插入规则：
        //1：2-3树的所有叶子节点都在同一层
        //2：有两个子节点的节点称为2节点 2/0，有三个子节点的节点称为3节点 3/0
        //3：当按照规则插入一个数据到某个节点时，不能满足上面2个要求，就需要拆
            //先向上拆，如果上层满，则拆本层，拆后仍要满足上面两个条件
        //4：对于三节点的子树的值，大小仍然遵循BST(二叉排序树)的规则

//过程如下
        //  16  ——》  16  24 --》    16           16                     16
        //                        12   24     12     24 32       12 14    24  32

        //              16  26                             16 26
        //      12  14     24      32           12 14       24     32 34

        //              16 26                                  16
        //      12        24     32 34                  12            26
        //    10  14  //违背所有叶子节点在同一层规则——》    10  14       24    32 34

        //              16                                16
        //          12      26                       12        26 32
        //      8 10   14  24   32 34            8 10  14    24  28  34

        //              16                                    16
        //          12       26 32                    12            26 32
        //     8 10   14   24   28   34 38      8 1O     14    20 24   28    34 38

//其他说明：除了2-3树，还有234树，概念和23树类似，也是一种B树
    //节点数比数据项数多一个


//B树，B+树，B*树介绍
    //B-tree树即B树，B即Balanced,平衡的意思，不存在B-树，
    //前面我们已经介绍了2-3树，2-3-4树，他们都是B树，在学习mysql时，经常听到说某种类型的索引
        //是基于B树或者B+树的
        //B树的阶：节点的最多子节点个数，比如2-3树的阶是3，2-3-4树的阶是4
        //B树的搜索，从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则
            //进入查询关键字所属范围的儿子节点，重复，直到所对应的儿子指针为空，或已经是叶子节点
        //关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据
        //搜索有可能在非叶子节点结束
        //其搜索性能等价于关键字全集内做一次二分查找

    //B+树：是B树的变体，也是一种多路搜索树，
        //B+树的搜索与B树基本相同，区别是B+树达到叶子节点才会命中，其性能等价于在关键字全集做一次二分查找
        //所有关键字都出现在叶子节点的链表中，即数据只存储在叶子节点（也叫稠密索引），且链表中的关键字是有序的
        //不可能在非叶子节点命中，非叶子结点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储（关键字）数据
            //的数据层
        //更适合文件索引系统
        //B树和B+树都有自己的应用场景，不能说B+树完全比B树好，反之亦然

    //B*树：是B+树的变体，在B+树的非根和非叶子节点再增加指向兄弟的指针
        //B*树定义了非叶子节点关键字个数至少为（2/3）*M,即块的最低使用率为2/3，而B+树的块
            //的最低使用率为B+树的1/2
        //从上面的特点可以看出，B*树分配新节点的概率要比B+树低，空间使用率更高




